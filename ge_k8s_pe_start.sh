#!/bin/bash
# Copyright 2019 CRS4.
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may not
# use this file except in compliance with the License. You may obtain a copy
# of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
# License for the specific language governing permissions and limitations
# under the License.

set -o nounset
set -o errexit
set -o pipefail
set -o errtrace

# initialize the bash environment if needed
# . /Archive/Software/Modules/3.2.10/init/bash

# portable version of abspath
function abspath() {
    local path="${*}"
    
    if [[ -d "${path}" ]]; then
        echo "$( cd "${path}" >/dev/null && pwd )"
    else
        echo "$( cd "$( dirname "${path}" )" >/dev/null && pwd )/$(basename "${path}")"
    fi
}

function script_dir() {
  echo "$(dirname $(abspath ${BASH_SOURCE[0]}))"
}

function log() {
    echo -e "${@}" >&2
}

function debug_log() {
    if [[ -n "${DEBUG:-}" ]]; then
        echo -e "DEBUG: ${@}" >&2
    fi
}

function error_log() {
    echo -e "ERROR: ${@}" >&2
}

function error_trap() {
    error_log "Error at line ${BASH_LINENO[1]} running the following command:\n\n\t${BASH_COMMAND}\n\n"
    error_log "Stack trace:"
    for (( i=1; i < ${#BASH_SOURCE[@]}; ++i)); do
        error_log "$(printf "%$((4*$i))s %s:%s\n" " " "${BASH_SOURCE[$i]}" "${BASH_LINENO[$i]}")"
    done
    exit 2
}

trap error_trap ERR

function usage_error() {
    if [[ $# > 0 ]]; then
        echo -e "ERROR: ${@}" >&2
    fi
    help
    exit 2
}

function help() {
    local script_name=$(basename "$0")
    echo -e "\nUsage: ${script_name}

    The following variables must be defined in your environment:

     - GE_K8S_MACHINE_FILE:              path of the machine file generated by GE (default: ${TMPDIR}/machines)
     - GE_K8S_NODE_START_SCRIPT          path to the script to join and boostrap a k8s node
     - GE_K8S_CONFIG_FILE:               defines environment variables to configure the ge-k8s join
     - GE_K8S_KUBEADM_CONFIG_TEMPLATE:   template of kubeadm config file
                                         actual values come from variables defined on GE_K8S_CONFIG_FILE
    ">&2
}

# initialize the bash environment if needed
# . /Archive/Software/Modules/3.2.10/init/bash

# get the path of the machine file generated by SGE
machine_file="${GE_K8S_MACHINE_FILE:-"${TMPDIR}/machines)"}"
if [[ ! -f "${machine_files}" ]]; then
    echo "Machine file doen't exist!"
    exit -1
fi

# set default GE_K8S_NODE_START
node_start_script=${GE_K8S_NODE_START_SCRIPT:-"$(script_dir)/ge_k8s_node_start.sh"}

# set default GE_K8S_CONFIG_FILE
config_file=${GE_K8S_CONFIG_FILE:-"$(script_dir)/ge_k8s_config.sh"}

# set default GE_K8S_KUBEADM_CONFIG_TEMPLATE
kubeadm_config_template=${GE_K8S_KUBEADM_CONFIG_TEMPLATE:-"$(script_dir)/gs_k8s_kubeadm_config.template"}

# load environment module for running the pdsh parallel shell tool
module load pdsh

# prepare the host list as needed by pdsh, i.e., host1,host2,hostn
# it might be useless, depending on the format of the machine file directly generated by SGE
for host in $(cat $machine_file | awk '{print $1}'); do
    hostlist="${hostlist}${host},"
done

# launch the k8s join on each SGE allocated node
pdsh -w ${hostlist} "<PATH_TO_THE_GE_K8S_START_BINARY> \
                     ${machine_file} ${node_start_script} \
                     ${GE_K8S_CONFIG_FILE} ${GE_K8S_KUBEADM_CONFIG_TEMPLATE}"